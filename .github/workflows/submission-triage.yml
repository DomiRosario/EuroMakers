name: Submission Triage

on:
  issues:
    types: [opened, reopened, edited]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  triage:
    if: ${{ !github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    concurrency:
      group: submission-triage-${{ github.event.issue.number }}
      cancel-in-progress: true

    steps:
      - name: Gate by submission label
        id: gate
        uses: actions/github-script@v7
        env:
          SUBMISSION_LABEL: ${{ vars.GITHUB_SUBMISSION_LABEL }}
          MAX_ISSUE_BODY_CHARS: "50000"
        with:
          script: |
            const issue = context.payload.issue;
            const labels = context.payload.issue.labels.map((label) => label.name);
            const submissionLabel = process.env.SUBMISSION_LABEL || "submission";
            const hasSubmissionLabel = labels.includes(submissionLabel);
            const body = issue.body || "";
            const bodySizeLimit = Number(process.env.MAX_ISSUE_BODY_CHARS || "50000");
            const hasPayloadMarker = /## Payload[\s\S]*?```json/i.test(body);
            const isBotSender = context.payload.sender?.type === "Bot";

            let reason = "passed";
            let shouldRun = true;
            if (!hasSubmissionLabel) {
              shouldRun = false;
              reason = "submission_label_missing";
            } else if (isBotSender) {
              shouldRun = false;
              reason = "sender_is_bot";
            } else if (body.length === 0) {
              shouldRun = false;
              reason = "body_empty";
            } else if (body.length > bodySizeLimit) {
              shouldRun = false;
              reason = "issue_body_too_large";
            } else if (!hasPayloadMarker) {
              shouldRun = false;
              reason = "payload_marker_missing";
            }

            core.setOutput("should_run", shouldRun ? "true" : "false");
            core.setOutput("has_submission_label", hasSubmissionLabel ? "true" : "false");
            core.setOutput("reason", reason);
            core.setOutput("body_length", String(body.length));

      - name: Close invalid labeled submissions
        if: steps.gate.outputs.should_run != 'true' && steps.gate.outputs.has_submission_label == 'true' && steps.gate.outputs.reason != 'submission_label_missing' && steps.gate.outputs.reason != 'sender_is_bot'
        uses: actions/github-script@v7
        with:
          script: |
            const marker = "<!-- moderation:invalid-submission -->";
            const reason = "${{ steps.gate.outputs.reason }}";
            const bodyLength = "${{ steps.gate.outputs.body_length }}";
            const message = [
              "This submission could not be processed automatically.",
              "",
              `Reason: \`${reason}\` (issue body length: ${bodyLength} characters).`,
              "",
              "Please submit again via `/submit` so the issue includes a valid `## Payload` JSON block within size limits.",
              "",
              marker,
            ].join("\n");

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            });
            const existing = comments.find((comment) => comment.body?.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: message,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: message,
              });
            }

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: "closed",
            });

      - name: Checkout
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/checkout@v4

      - name: Save issue body
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("node:fs");
            fs.writeFileSync("submission-issue.md", context.payload.issue.body || "", "utf8");

      - name: Parse submission payload
        if: steps.gate.outputs.should_run == 'true'
        run: node scripts/moderation/parse-submission-issue.mjs --body-file submission-issue.md --output submission-payload.json

      - name: Score submission
        if: steps.gate.outputs.should_run == 'true'
        run: node scripts/moderation/score-submission.mjs --input submission-payload.json --output moderation-score.json --software-dir data/software

      - name: Download submitted logo
        if: steps.gate.outputs.should_run == 'true'
        run: node scripts/moderation/download-logo.mjs --input moderation-score.json --output moderation-score.json --images-dir public/images

      - name: Export score outputs
        if: steps.gate.outputs.should_run == 'true'
        id: score
        run: |
          node -e 'const fs=require("fs"); const data=JSON.parse(fs.readFileSync("moderation-score.json","utf8")); const out=process.env.GITHUB_OUTPUT; const assets=Array.isArray(data.generatedAssets)?data.generatedAssets.filter(Boolean):[]; const targetPath=typeof data.targetPath==="string"?data.targetPath:""; fs.appendFileSync(out,`decision=${data.decision}\n`); fs.appendFileSync(out,`score=${data.score}\n`); fs.appendFileSync(out,`id=${data.normalizedEntry.id}\n`); fs.appendFileSync(out,`target_path=${targetPath}\n`); if (assets.length) { fs.appendFileSync(out,`asset_paths<<EOF\n${assets.join("\n")}\nEOF\n`); } else { fs.appendFileSync(out,"asset_paths=\n"); }'

      - name: Publish moderation result
        if: steps.gate.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("node:fs");
            const result = JSON.parse(fs.readFileSync("moderation-score.json", "utf8"));
            const marker = "<!-- moderation:score -->";
            const decisionText = result.decision === "auto-merge"
              ? "Auto-merge"
              : result.decision === "manual-review"
                ? "Manual review"
                : "Rejected";

            const breakdown = [
              `- Schema validity: ${result.breakdown.schemaValidity}/20`,
              `- Website reachability: ${result.breakdown.websiteReachability}/20`,
              `- Evidence reachability: ${result.breakdown.evidenceReachability}/15`,
              `- European origin: ${result.breakdown.europeanOrigin}/15`,
              `- Duplicate/domain collision: ${result.breakdown.duplicateDomain}/10`,
              `- Content quality: ${result.breakdown.contentQuality}/10`,
              `- Spam heuristics: ${result.breakdown.spamHeuristics}/10`,
            ].join("\n");

            const reasons = result.reasons.length
              ? result.reasons.map((reason) => `- ${reason}`).join("\n")
              : "- No warnings detected";

            const body = [
              `Moderation score: **${result.score}/100**`,
              `Decision: **${decisionText}**`,
              "",
              "### Breakdown",
              breakdown,
              "",
              "### Notes",
              reasons,
              "",
              marker,
            ].join("\n");

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            });

            const existing = comments.find((comment) => comment.body?.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

            if (result.decision === "reject") {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: "closed",
              });
            }

      - name: Render software JSON
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision != 'reject'
        run: node scripts/moderation/render-software-json.mjs --input moderation-score.json

      - name: Validate generated file paths
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision != 'reject'
        env:
          TARGET_PATH: ${{ steps.score.outputs.target_path }}
          ASSET_PATHS: ${{ steps.score.outputs.asset_paths }}
        run: |
          node -e 'const target=String(process.env.TARGET_PATH||"").trim(); const assets=String(process.env.ASSET_PATHS||"").split(/\r?\n/).map(v=>v.trim()).filter(Boolean); const targetPattern=/^data\/software\/[a-z0-9-]+\/[a-z0-9-]+\.json$/; if(!targetPattern.test(target) || target.includes("..")) { throw new Error(`Unsafe target_path: ${target}`); } const assetPattern=/^public\/images\/[a-z0-9-]+_icon\.(png|jpg|webp|svg|ico|gif)$/; for(const asset of assets){ if(asset.includes("..") || !assetPattern.test(asset)){ throw new Error(`Unsafe asset path: ${asset}`); } }'

      - name: Require moderation token
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision != 'reject'
        env:
          MODERATION_TOKEN: ${{ secrets.GITHUB_MODERATION_TOKEN }}
        run: |
          if [ -z "$MODERATION_TOKEN" ]; then
            echo "GITHUB_MODERATION_TOKEN is required for moderation write actions."
            exit 1
          fi

      - name: Create pull request
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision != 'reject'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_MODERATION_TOKEN }}
          commit-message: "chore(submission): add ${{ steps.score.outputs.id }}"
          title: "[Submission] Add ${{ steps.score.outputs.id }}"
          body: |
            Automated moderation result for issue #${{ github.event.issue.number }}.

            - Score: ${{ steps.score.outputs.score }}/100
            - Decision: ${{ steps.score.outputs.decision }}

            Closes #${{ github.event.issue.number }}
          branch: automation/submission-${{ github.event.issue.number }}-${{ steps.score.outputs.id }}
          labels: |
            submission
          add-paths: |
            ${{ steps.score.outputs.target_path }}
            ${{ steps.score.outputs.asset_paths }}

      - name: Apply decision labels to pull request
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision != 'reject' && steps.cpr.outputs.pull-request-number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = Number("${{ steps.cpr.outputs.pull-request-number }}");
            const labels = ["moderation:${{ steps.score.outputs.decision }}"];
            if ("${{ steps.score.outputs.decision }}" === "manual-review") {
              labels.push("manual-review");
            }

            for (const name of labels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name,
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name,
                    color: "1D4ED8",
                  });
                } else {
                  throw error;
                }
              }
            }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels,
            });

      - name: Comment issue with PR link
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision != 'reject' && steps.cpr.outputs.pull-request-url != ''
        uses: actions/github-script@v7
        with:
          script: |
            const marker = "<!-- moderation:pr-link -->";
            const body = `Created moderation PR: ${{ steps.cpr.outputs.pull-request-url }}\n\n${marker}`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              per_page: 100,
            });
            const existing = comments.find((comment) => comment.body?.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

      - name: Enable auto-merge for high confidence
        if: steps.gate.outputs.should_run == 'true' && steps.score.outputs.decision == 'auto-merge' && steps.cpr.outputs.pull-request-number != ''
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.GITHUB_MODERATION_TOKEN }}
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash
